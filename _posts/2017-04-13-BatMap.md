---
layout: post
title: BatMap
comments: true
redirect_from: "/2017/04/13/BatMap - Yeni bir Mapper daha/"
permalink: batmap-yeni-bir-mapper-daha
---
[BatMap](http://github.com/DogusTeknoloji/BatMap "Beetle.js") C# dili ile geliştirilmiş yeni bir Mapper.
Hemen akıllara gelen soru: "Neden bir Mapper daha?"

![Standards]( https://imgs.xkcd.com/comics/standards.png)

<sup>[xkcd - standards](https://xkcd.com/927/ "xkcd - standards")<sup>

Neden olmasın?

# Hemen açıklayayım

Diyelim ki aşağıdaki gibi bir sınıf yapınız var;

{% highlight csharp %}
public class Order {
    public int Id { get; set; }
    public string OrderNo { get; set; }
    public double Price { get; set; }
    public List<OrderDetail> OrderDetails { get; set; }
}

public class OrderDetail {
    public int Id { get; set; }
    public int Count { get; set; }
    public double UnitPrice { get; set; }
    public Order Order { get; set; }
}
{% endhighlight %}

Sipariş ve Sipariş Detay sınıfları iki taraflı ilişkili. DTO sınıflarınız da aşağıdaki gibi olsun;

{% highlight csharp %}
public class OrderDTO {
    public int Id { get; set; }
    public string OrderNo { get; set; }
    public List<OrderDetailDTO> OrderDetails { get; set; }
}

public class OrderDetailDTO {
    public int Id { get; set; }
    public int Count { get; set; }
    public double UnitPrice { get; set; }
    public OrderDTO Order { get; set; }
}
{% endhighlight %}

Bu ilişkiyi DTO sınıflarında da yukarıdaki gibi koruduğunuzda bir çok Mapper kayıt aşamasında StackOverflowException hatası üretirler. Neden mi?
Eğer bu araçların nasıl çalıştıklarını incelediyseniz sizin için otomatik kod ürettiklerini farketmişsinizdir, aşağıdaki gibi;

{% highlight csharp %}
Expression<Func<Order, OrderDTO>> orderMapperExpression = o => new OrderDTO {
    Id = o.Id,
    OrderNo = o.OrderNo,
    // Price alanı DTO üzerinde olmadığından atlanır
    OrderDetails = o.OrderDetails.Select(od => new OrderDetailDTO {
        Id = od.Id,
        Count = od.Count,
        UnitPrice = od.UnitPrice,
        Order = new OrderDTO {
            ...
        }
    });
};
{% endhighlight %}

Sorunu görebildiniz mi? ... ile devamını getirmediğim kısım Mapper'ın sonsuz döngüye girip StackOverflowException hatasına sebep olmasıyla sonuçlanıyor.

Bazı Mapper'lar kayıt aşamasında ilişkiler için temsili bir atama oluşturarak bu hatanın önüne geçebiliyorlar, ancak sadece kayıt sırasında. Gerçekten bir Mapping işlemi yapmak istediğinizde bu iki ilişkinin de dolu olması durumunda beklenmedik bir anda aynı şekilde StackOverflowException alıyorsunuz.

# Çözüm

Bir Map süreci başladığında bu süreci temsil eden bir sınıfımız olsa (MapContext) ve bu sınıfı kullanarak kayıt işlemlerini aşağıdaki gibi yaparsak;

{% highlight csharp %}
Expression<Func<Order, MapContext, OrderDTO>> orderMapperExpression = (o, mc) => new OrderDTO {
    Id = o.Id,
    OrderNo = o.OrderNo,
    OrderDetails = mc.MapToList<OrderDetail, OrderDetailDTO>(o.OrderDetails)
};

Expression<Func<OrderDetail, MapContext, OrderDetailDTO>> orderDetailMapperExpression = (od, mc) => new OrderDetailDTO {
    Id = o.Id,
    Count = o.Count,
    UnitPrice = o.UnitPrice,
    Order = mc.Map<Order, Order>(o.Order)
};
{% endhighlight %}

Kayıt sırasında tüm ilişki ağacını gezmeden çok daha basit ifadeler oluşturabiliyoruz.

Bu yapı da çalışma zamanı aynı hataya sebep olabilir, bir şekilde tekrar tekrar aynı objelerin oluşturulmasına engel olabilmeliyiz.

## MapWithCache metodu

Referans koruyarak Map işlemi burada devreye giriyor;

{% highlight csharp %}
Mapper.Map<OrderDTO>(order, preserveReferences: true);
{% endhighlight %}

Eğer Map işlemimizi yukarıdaki şekilde çağırırsak atama için otomatik oluşturduğumuz kodun biraz değiştirilmiş bir versiyonu çalışacak;

{% highlight csharp %}
Expression<Func<Order, MapContext, OrderDTO>> orderMapperExpression = (o, mc) => {
    OrderDTO orderDTO;
    if (mc.GetFromCache(o, typeof(OrderDTO), out orderDTO)) {
        return orderDTO;
    }
    orderDTO = new OrderDTO();
    mc.NewInstance(o, orderDTO);

    orderDTO.Id = o.Id;
    orderDTO.OrderNo = o.OrderNo;
    orderDTO.OrderDetails = mc.MapToList<OrderDetail, OrderDetailDTO>(o.OrderDetails);
    return orderDTO;
};
{% endhighlight %}

OrderDetail için oluşturulan kodu hayal gücünüze bırakıyorum.

Şimdi kodun nasıl çalıştığını inceleyelim;

* Her bir Map işleminden önce kullanacağımız nesne için hedef tipteki bir nesneyi ön bellekten istiyoruz
* Eğer bu nesne daha önce bu hedef tip için Map işlemine girmişse hazır nesneyi dönüyoruz
* Ön bellekte bulamaz isek daha fazla ilerlemeden (ilişkiler için Map işlemi yapmadan) ön belleğe bu yeni nesneyi koyuyoruz
* Normal bir şekilde Map işlemine devam ediyoruz

Böylece istediğimiz karışıklıktaki sınıfları birbirine dönüştürebiliyoruz.

# Performans?

Gördüğünüz gibi diğer Mapper'lara göre hatırı sayılır derecede fazla işlem yapıyoruz, peki nasıl bir çoğundan daha hızlı çalışıyor?

Genel kullanım bu Expression'ları .Compile() metodu ile çalıştırlabilir metodlara derlemektir (en basit yöntem de budur).
