---
layout: post
title: BatMap
comments: true
redirect_from: "/2017/04/13/BatMap - Yeni bir Mapper daha/"
permalink: batmap-yeni-bir-mapper-daha
---
[BatMap](http://github.com/DogusTeknoloji/BatMap "Beetle.js")  C# dili ile gelitirilmi yeni bir Mapper.
Hemen ak覺llara gelen soru: "Neden bir Mapper daha?"

![Standards]( https://imgs.xkcd.com/comics/standards.png)

<sup>[xkcd - standards](https://xkcd.com/927/ "xkcd - standards")<sup>

Neden olmas覺n?

# Hemen a癟覺klayay覺m

Diyelim ki aa覺daki gibi bir s覺n覺f yap覺n覺z var:

{% highlight csharp %}
public class Order {
    public int Id { get; set; }
    public string OrderNo { get; set; }
    public double Price { get; set; }
    public List<OrderDetail> OrderDetails { get; set; }
}

public class OrderDetail {
    public int Id { get; set; }
    public int Count { get; set; }
    public double UnitPrice { get; set; }
    public Order Order { get; set; }
}
{% endhighlight %}

Sipari ve Sipari Detay s覺n覺flar覺 iki tarafl覺 ilikili. DTO s覺n覺flar覺n覺z da aa覺daki gibi olsun:

{% highlight csharp %}
public class OrderDTO {
    public int Id { get; set; }
    public string OrderNo { get; set; }
    public List<OrderDetailDTO> OrderDetails { get; set; }
}

public class OrderDetailDTO {
    public int Id { get; set; }
    public int Count { get; set; }
    public double UnitPrice { get; set; }
    public OrderDTO Order { get; set; }
}
{% endhighlight %}

Bu ilikiyi DTO s覺n覺flar覺nda da yukar覺daki gibi koruduunuzda bir 癟ok Mapper kay覺t aamas覺nda StackOverflowException hatas覺 羹retirler. Neden mi?
Eer bu ara癟lar覺n nas覺l 癟al覺t覺klar覺n覺 incelediyseniz sizin i癟in otomatik kod 羹rettiklerini farketmisinizdir, aa覺daki gibi:

{% highlight csharp %}
Expression<Func<Order, OrderDTO>> orderMapperExpression = o => new OrderDTO {
    Id = o.Id,
    OrderNo = o.OrderNo,
    // Price alan覺 DTO 羹zerinde olmad覺覺ndan atlan覺r
    OrderDetails = o.OrderDetails.Select(od => new OrderDetailDTO {
        Id = od.Id,
        Count = od.Count,
        UnitPrice = od.UnitPrice,
        Order = new OrderDTO {
            ...
        }
    });
};
{% endhighlight %}

Sorunu g繹rebildiniz mi? ... ile devam覺n覺 getirmediim k覺s覺m Mapper'覺n sonsuz d繹ng羹ye girip StackOverflowException hatas覺na sebep olmas覺yla sonu癟lan覺yor.

Baz覺 Mapper'lar kay覺t aamas覺nda ilikiler i癟in temsili bir atama oluturarak bu hatan覺n 繹n羹ne ge癟ebiliyorlar, ancak sadece kay覺t s覺ras覺nda. Ger癟ekten bir Mapping ilemi yapmak istediinizde bu iki ilikinin de dolu olmas覺 durumunda beklenmedik bir anda ayn覺 ekilde StackOverflowException al覺yorsunuz.

# 繹z羹m

Bir Map s羹reci balad覺覺nda bu s羹reci temsil eden bir s覺n覺f覺m覺z olsa (MapContext) ve bu s覺n覺f覺 kullanarak kay覺t ilemlerini aa覺daki gibi yaparsak:

{% highlight csharp %}
Expression<Func<Order, MapContext, OrderDTO>> orderMapperExpression = (o, mc) => new OrderDTO {
    Id = o.Id,
    OrderNo = o.OrderNo,
    OrderDetails = mc.MapToList<OrderDetail, OrderDetailDTO>(o.OrderDetails)
};

Expression<Func<OrderDetail, MapContext, OrderDetailDTO>> orderDetailMapperExpression = (od, mc) => new OrderDetailDTO {
    Id = o.Id,
    Count = o.Count,
    UnitPrice = o.UnitPrice,
    Order = mc.Map<Order, Order>(o.Order)
};
{% endhighlight %}

Kay覺t s覺ras覺nda t羹m iliki aac覺n覺 gezmeden 癟ok daha basit ifadeler oluturabiliyoruz.

Bu yap覺 da 癟al覺ma zaman覺 ayn覺 hataya sebep olabilir, bir ekilde tekrar tekrar ayn覺 objelerin oluturulmas覺na engel olabilmeliyiz.

## MapWithCache metodu

Referans koruyarak Map ilemi burada devreye giriyor:

{% highlight csharp %}
Mapper.Map<OrderDTO>(order, preserveReferences
true);
{% endhighlight %}

Eer Map ilemimizi yukar覺daki ekilde 癟a覺r覺rsak atama i癟in otomatik oluturduumuz kodun biraz deitirilmi bir versiyonu 癟al覺acak:

{% highlight csharp %}
Expression<Func<Order, MapContext, OrderDTO>> orderMapperExpression = (o, mc) => {
    OrderDTO orderDTO;
    if (mc.GetFromCache(o, typeof(OrderDTO), out orderDTO)) {
        return orderDTO;
    }
    orderDTO = new OrderDTO();
    mc.NewInstance(o, orderDTO);

    orderDTO.Id = o.Id;
    orderDTO.OrderNo = o.OrderNo;
    orderDTO.OrderDetails = mc.MapToList<OrderDetail, OrderDetailDTO>(o.OrderDetails);
    return orderDTO;
};
{% endhighlight %}

OrderDetail i癟in oluturulan kodu hayal g羹c羹n羹ze b覺rak覺yorum.

imdi kodun nas覺l 癟al覺t覺覺n覺 inceleyelim:

* Her bir Map ileminden 繹nce kullanaca覺m覺z nesne i癟in hedef tipteki bir nesneyi 繹n bellekten istiyoruz
* Eer bu nesne daha 繹nce bu hedef tip i癟in Map ilemine girmise haz覺r nesneyi d繹n羹yoruz
* n bellekte bulamaz isek daha fazla ilerlemeden (ilikiler i癟in Map ilemi yapmadan) 繹n bellee bu yeni nesneyi koyuyoruz
* Normal bir ekilde Map ilemine devam ediyoruz

B繹ylece istediimiz kar覺覺kl覺ktaki s覺n覺flar覺 birbirine d繹n羹t羹rebiliyoruz.

# Performans?

|        Method |      Mean |    StdDev |
|-------------- |---------- |---------- |
|        BatMap | 1.8563 ms | 0.0106 ms |
|       Mapster | 2.0414 ms | 0.0079 ms |
|    SafeMapper | 2.0589 ms | 0.0572 ms |
|   HandWritten | 2.1000 ms | 0.0079 ms |
|    AutoMapper | 2.7422 ms | 0.0157 ms |
|    TinyMapper | 2.8609 ms | 0.0099 ms |
| ExpressMapper | 4.9961 ms | 0.0128 ms |
|    FastMapper | 5.7874 ms | 0.0186 ms |

<sup>Premature optimization is the root of all evil! s繹z羹n羹 unutmay覺n. Burada yapt覺覺m performans 癟al覺malar覺n覺 biraz deneysel biraz da Mapper projelerinin baar覺s覺nda bir numaral覺 kriter kabul edildii i癟in yapt覺m. Performans, projeniz ilerledik癟e hedeflediiniz s羹releri alamazsan覺z d羹羹nmeniz gereken bir konu olmal覺.</sup>

G繹rd羹羹n羹z gibi dier Mapper'lara g繹re hat覺r覺 say覺l覺r derecede fazla ilem yap覺yoruz (preserveReferences aktif olmad覺覺nda bile), peki nas覺l bir 癟oundan daha h覺zl覺 癟al覺覺yor?

Genel kullan覺m bu Expression'lar覺 .Compile() metodu ile 癟al覺t覺rlabilir metodlara derlemektir (en basit y繹ntem de budur).
Ancak pek bilinmeyen nokta .Compile() ile derlenmi metodun 癟al覺abilmesi i癟in Delegate 癟evirimi yap覺l覺r:

{% highlight csharp %}
System.Reflection.Emit.DynamicMethod.CreateDelegate(class System.Type, object)
{% endhighlight %}

Bunun sebebini en basit haliyle C# dilinin mimari olarak bir Assembly-Type ilikisi olmayan fonksiyona sahip olamamas覺d覺r diyebiliriz (dinamik ve fonksiyonel dillerin aksine). Bir 癟ok Mapper kay覺t s覺ras覺nda .Compile() ile 癟al覺t覺r覺lacak kodu 羹reterek 繹nemli bir optimizasyonu g繹zden ka癟覺rm覺 oluyorlar. Aa覺daki gibi bir kod ile her Map metodunu yeni oluturuduumuz bir tip i癟ine static metod olarak eklersek ve Delegate 羹retme k覺sm覺n覺 biz 羹stlenirsek 繹l癟羹mlerime g繹re %30 civar覺 bir performans art覺覺 g繹zlemleyebiliyoruz (baz覺 kaynaklarda %90 羹zeri olduundan bahsediliyor ancak efektif deerlerde bunu g繹remedim):

{% highlight csharp %}
var assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(new AssemblyName("BatMap_DynamicAssembly"), AssemblyBuilderAccess.Run);
var moduleBuilder = assembly.DefineDynamicModule("BatMap_DynamicModule");
var typeBuilder = moduleBuilder.DefineType("BatMap_DynamicType" + _typeCounter++, TypeAttributes.Public);
var methodBuilder = typeBuilder.DefineMethod("BatMap_DynamicMethod", MethodAttributes.Public | MethodAttributes.Static);
expression.CompileToMethod(methodBuilder);
var type = typeBuilder.CreateType();
return Delegate.CreateDelegate(delegateType, type.GetMethod("BatMap_DynamicMethod"));
{% endhighlight %}

## Daha da performans
Dier Mapper'lara g繹re daha fazla i yapt覺覺m覺z覺 s繹ylemitim, bu ilerden bir tanesi de 癟al覺t覺r覺lacak t羹m Map kodunu 羹retmek yerine MapContext 羹zerinden gerekli durumlarda 癟ar覺lar yapmak:
{% highlight csharp %}
orderDTO.OrderDetails = mc.MapToList<OrderDetail, OrderDetailDTO>(o.OrderDetails);
{% endhighlight %}
otomatik oluturulan kodlardan yukar覺daki sat覺r覺 OrderDetail ve OrderDetailDTO aras覺ndaki Map kodunu bul ve bunu o.OrderDetails parametresiyle 癟a覺r eklinde d羹羹nebiliriz. Yani bizim elimizde her Map kayd覺 yap覺lm覺 tip ikilileri i癟in (MapPair) Map tan覺mlar覺 (MapDefinition) olmas覺 gerekiyor ve bunlara 癟ok h覺zl覺 eriebilmemiz gerekiyor. Akla ilk gelen bu iki tip i癟in bir Tuple oluturup bu kay覺tlar覺 aa覺daki gibi bir Dictionary ile saklamak:
{% highlight csharp %}
Dictionary<Tuple<Type, Type>, IMapDefinition> mapDefinitions;
{% endhighlight %}
Bildiiniz gibi Dictionary kay覺tlar覺 saklarken Key nesnesinin GetHashCode metodundan d繹nen deeri indekslemek i癟in kullan覺r.
Dolay覺s覺yla Tuple'覺n GetHashCode uygulamas覺n覺 ~~kullanan bir struct yazarak (MapPair)~~ ile sadece int deeri kullanarak 繹nemli bir performans art覺覺 salayabiliyoruz. Aa覺da Dictionary ve HashCode 羹reten kodu g繹rebilirsiniz:
{% highlight csharp %}
Dictionary<int, IMapDefinition> mapDefinitions;

public static int GenerateHashCode(object o1, object o2) {
    var h1 = o1.GetHashCode();
    var h2 = o2.GetHashCode();
    return ((h1 << 5) + h1) ^ h2;
}
{% endhighlight %}
<sup>*Not: Optimizasyonu biraz abartt覺m, arac覺 struct'lar覺 (MapPair ve CachePair) sildim, onlar覺n yerine direk 羹retilecek olan int deerleri kullan覺yorum. B繹ylece hem daha ufak bir bellek imzas覺na sahip oluyoruz hem de performansta %10'a kadar art覺 g繹rebiliyoruz.*</sup>

Bir dier ufak optimizasyon noktas覺 da bize verilen tipli bir listeyi baka tipli bir listeye 癟evirirken (MapToList) kar覺m覺za 癟覺k覺yor.
Bu durumla kar覺laan bir 癟ok yaz覺l覺mc覺 i癟g羹d羹sel olarak aa覺daki kodu yazacakt覺r:
{% highlight csharp %}
var mapDefinition = (IMapDefinition<TIn, TOut>)_mapper.GetMapDefinition(inType, outType);
var mapper = PreserveReferences ? mapDefinition.MapperWithCache : mapDefinition.Mapper;
return source.Select(i => mapper(i, this)).ToList();
{% endhighlight %}

Bu kodda 癟ok ufak deiiklikler yaparak GitHub 羹zerinden eriebileceiniz Benchmark projesini 癟al覺t覺rd覺覺m覺zda %25-%35 aras覺 performans art覺覺 salayabiliyoruz:
{% highlight csharp %}
var count = source.Count();
// listeyi belirli adet i癟in olutur, bellek ay覺rma ii ortadan kalks覺n
var retVal = new List<TOut>(count);
// bo liste i癟in GetMapDefinition 癟al覺t覺rmadan d繹n
if (count == 0) return retVal;

var mapDefinition = (IMapDefinition<TIn, TOut>)_mapper.GetMapDefinition(inType, outType);
var mapper = PreserveReferences ? mapDefinition.MapperWithCache : mapDefinition.Mapper;
foreach (var i in source) {
    retVal.Add(mapper(i, this));
}

return retVal;
{% endhighlight %}
Burada dikkat edilmesi gereken noktalar:
* List her .Add 癟ar覺s覺nda yeterli bellek ay覺r覺lm覺 olup olmad覺覺na bakar, gerekirse bellek ister. Biz tam ihtiyac覺m覺z kadar bellek ay覺rmas覺n覺 ilk ad覺mda salayarak bu ad覺mdan kurtulmu oluyoruz.
* Liste bo ise hi癟 GetMapDefinition 癟a覺rmadan bo liste d繹n羹yoruz
* Bir de .Count() metoduna deinelim. Genelde IEnumerable 羹zerinden yap覺lan .Count() 癟ar覺s覺n覺n t羹m listeyi gezdii d羹羹n羹l羹r. Ancak kar覺laaca覺m覺z 癟ou senaryoda asl覺nda bu listeler bir List, Collection ya da bu gibi bir Concrete tiptir. Bu durumda .Count() 癟ar覺s覺 arka planda O(1) ile 癟al覺an .Count property eriimiyle salan覺r ve bir performans kayb覺 yaanmaz.
